#version 460

#extension GL_GOOGLE_include_directive: require
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(constant_id = 0) const uint SEGMENT_COUNT = 1;
layout(constant_id = 1) const uint SAMPLES_PER_SEGMENT = 1;
layout(constant_id = 2) const uint VERTICES_PER_SAMPLE = 1;
layout(constant_id = 3) const uint FIREFLIES_PER_SEGMENT = 1;

layout(binding = 0) buffer TunnelIndexBuffer {
    uint indices[];
};

layout(binding = 1) buffer TunnelVertexBuffer {
    AlignedTunnelVertex vertices[];
};

layout(binding = 2) buffer FireflyVertexBuffer {
    AlignedFireflyVertex firefly_vertices[];
};

layout(binding = 3) buffer TunnelBezierPointsBuffer {
    vec3 tunnel_bezier_points[];
};

layout(push_constant) uniform PushConstant {
    NewSegmentPushConstants pc;
};

float random(vec2 st) {
    st = vec2(dot(st,vec2(127.1, 311.7)), dot(st,vec2(269.5, 183.3)));
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

// rotate v around k by angle degrees
vec3 rotate(vec3 v, vec3 k, float angle)
{
    float cos_theta = cos(radians(angle));
    float sin_theta = sin(radians(angle));
    vec3 rotated = (v * cos_theta) + (cross(k, v) * sin_theta) + (k * dot(k, v)) * (1 - cos_theta);
    return rotated;
}

void main()
{
    if (gl_GlobalInvocationID.x == 0)
    {
        tunnel_bezier_points[(pc.segment_uid * 2 + 1) % (SEGMENT_COUNT * 2 + 3)] = pc.p1;
        tunnel_bezier_points[(pc.segment_uid * 2 + 2) % (SEGMENT_COUNT * 2 + 3)] = pc.p2;
    }
    if (gl_GlobalInvocationID.x < SAMPLES_PER_SEGMENT * VERTICES_PER_SAMPLE)
    {
        // what circle of vertices this thread belongs to
        uint sample_circle_id = gl_GlobalInvocationID.x / VERTICES_PER_SAMPLE;
        // what vertex in the circle this thread belongs to
        uint vertex_id = gl_GlobalInvocationID.x % VERTICES_PER_SAMPLE;
        // interpolate over bézier points to get position and normal of sample
        float t = float(sample_circle_id) / float(SAMPLES_PER_SEGMENT - 1);
        vec3 sample_pos = pow(1 - t, 2) * pc.p0 + (2 - 2 * t) * t * pc.p1 + pow(t, 2) * pc.p2;
        // normal is given by derivative
        vec3 plane_normal = normalize((2 - 2 * t) * (pc.p1 - pc.p0) + 2 * t * (pc.p2 - pc.p1));
        // calculate vector that lies in the plane of the circle
        vec3 plane_vector = abs(dot(plane_normal, vec3(1.0, 0.0, 0.0))) >= 0.999999 ? cross(plane_normal, normalize(vec3(0.99, 0.0, 0.01))) : cross(plane_normal, vec3(1.0, 0.0, 0.0));
        // vector from center of circle to vertex position
        vec3 vertex_pos = normalize(rotate(plane_vector, plane_normal, (360.0 / VERTICES_PER_SAMPLE) * vertex_id));
        vec3 normal = -vertex_pos;
        vertex_pos *= 20.0;
        // actual position of vertex
        vertex_pos += sample_pos;

        TunnelVertex v;
        v.pos = vertex_pos;
        v.normal = normal;
        v.tex = vec2(abs((pc.segment_uid % 2) - float(sample_circle_id) / float(SAMPLES_PER_SEGMENT - 1)), abs((float(vertex_id) / float(VERTICES_PER_SAMPLE)) * 2.0 - 1.0));
        v.segment_uid = pc.segment_uid;
        vertices[indices[pc.indices_start_idx] + gl_GlobalInvocationID.x] = pack_tunnel_vertex(v);
    }
    if (gl_GlobalInvocationID.x < FIREFLIES_PER_SEGMENT)
    {
        float t = random(vec2(gl_GlobalInvocationID.x, pc.segment_uid));
        uint idx = (pc.segment_uid % SEGMENT_COUNT) * FIREFLIES_PER_SEGMENT + gl_GlobalInvocationID.x;
        // spawn lights in the middle of the tunnel by using a random position on the bézier curve
        FireflyVertex v;
        v.pos = pow(1 - t, 2) * pc.p0 + (2 - 2 * t) * t * pc.p1 + pow(t, 2) * pc.p2;
        v.col = vec3(1.0, 0.0, 1.0);
        v.vel = vec3(0.0, 0.0, 0.0);
        v.acc = vec3(1.0, 1.0, 1.0);
        firefly_vertices[idx] = pack_firefly_vertex(v);
    }
}
